<link rel="import" href="../polymer/polymer.html">
<!-- <link rel="import" href="../th-data-table/th-data-table.html"> -->
<link rel="import" href="../core-menu/core-menu.html">
<link rel="import" href="../core-item/core-item.html">
<link rel="import" href="../core-icons/core-icons.html">
<link rel="import" href="../core-collapse/core-collapse.html">
<link rel="import" href="../th-data-criterion/th-data-criterion.html">
<link rel="import" href="../th-data-selector/th-data-selector.html">

<polymer-element name="th-lens-node" attributes="input output componentList type pathToComponents">
  
    <core-style ref="theme"></theme>
    <template>
    <link rel="stylesheet" href="th-lens-node.css">

    <div id="node" class="{{type}}">
      <!-- Common among all nodes -->
      
      <!-- INPUT NODE -->
      <template if="{{type==='input'}}">
        <div class="heading input-background"> Data Input </div>
        <div id="view">

          Choose data source:<core-icon icon="menu" on-click="{{toggle}}" data-target="collapse-view"></core-icon>
          <!-- Name of component selected -->
          <template if="{{component}}">
            <core-item label="{{componentName}}"> <core-icon icon="clear" on-click="{{removeElement}}"> </core-icon>   </core-item>
          </template>
          
          <core-collapse id="collapse-view" opened>
            <template if="{{!component}}">  
              <!-- Menu of components to choose from -->
              <core-menu id="component-list">
                <template repeat="{{component in componentList | filterByType}}">
                  <core-item class="{{component.name}}" on-click="{{addElement}}" label="{{component.friendly}}"></core-item>
                </template>
              </core-menu>
            </template>
        
            <!-- Component itself -->
            <content id="component"></content>
          </core-collapse>

        </div>
      </template>

      <!-- TRANSFORM NODE -->
      <template if="{{type==='transform'}}">
        <div class="heading transform-background"> Transform Data </div>
        <div id="select">
          Select data: <core-icon icon="menu" data-target="collapse-select" on-click="{{toggle}}"></core-icon>
          <core-collapse id="collapse-select">
            Filter Options<th-data-criterion id="transformfilter" input="{{input}}"></th-data-criterion>
            <th-data-table id="inputTable" firstRowIsHeader="{{firstRow}}" input="{{$.transformfilter.output || input}}" output="{{componentInput}}"></th-data-table>
          </core-collapse>
        </div>
        
        <div id="transform">
          Transform:<core-icon icon="menu" on-click="{{toggle}}" data-target="collapse-transform"></core-icon>
          <!-- Name of component selected -->
          <template if="{{component}}">
            <core-item label="{{componentName}}"> <core-icon icon="clear" on-click="{{removeElement}}"> </core-icon>   </core-item>
          </template>

          <!-- *** Collapsible *** -->
            <core-collapse id="collapse-transform">
              <!-- Menu of components to choose from -->
              <template if="{{!component}}">
                <core-menu id="component-list">
                    <!-- <core-item class="core-selected" label="None"></core-item> -->
                  <template repeat="{{component in componentList | filterByType}}">
                    <core-item class="{{component.name}}" on-click="{{addElement}}" label="{{component.friendly}}"></core-item>
                  </template>
                </core-menu>
              </template>

              <!-- Component itself -->
              <content id="component"></content>
            </core-collapse>
          <!-- ***** -->
        </div>
        
        <div id="view">
          View Result (read only)<core-icon icon="menu" on-click="{{toggle}}" data-target="collapse-view"></core-icon>
          <core-collapse id="collapse-view">
            <th-data-table id="outputTable"  firstRowIsHeader="{{firstRow}}" output="{{output}}"  readOnly="true"></th-data-table>
          </core-collapse>
        </div>
      </template>

      <!-- VISUALIZE NODE -->
      <template if="{{type==='visualize'}}">
        <div class="heading visualize-background"> Visualize </div>
        <div id="select">
          Select Data:<core-icon icon="menu" on-click="{{toggle}}" data-target="collapse-select"></core-icon>
          
          <core-collapse id="collapse-select">
            Filter Options<th-data-criterion id="visualfilter" input="{{input}}" output="{{filterOutput}}"></th-data-criterion>
            <th-data-table id="inputTable" input="{{filterOutput || input}}" output="{{componentInput}}"></th-data-table>
          </core-collapse>
          <template if="{{showDataSelector}}">  
            <th-data-selector id="dataselector" input="{{componentInput}}" dataFields="{{fields}}" output="{{selectedComponentInput}}"></th-data-selector>
          </template>
        </div>

        <div id="view">
          Choose a visual:<core-icon icon="menu" on-click="{{toggle}}" data-target="collapse-view"></core-icon>
          <!-- Name of component selected -->
          <template if="{{component}}">
            <core-item label="{{componentName}}"> <core-icon icon="clear" on-click="{{removeElement}}"> </core-icon>   </core-item>
          </template>
          
          <core-collapse id="collapse-view">
            <template if="{{!component}}">  
              <!-- Menu of components to choose from -->
              <core-menu id="component-list">
                <template repeat="{{component in componentList | filterByType}}">
                  <core-item class="{{component.name}}" on-click="{{addElement}}" label="{{component.friendly}}"></core-item>
                </template>
              </core-menu>
            </template>
          
            
            <!-- Component itself -->
            <content id="component"></content>
          </core-collapse>
        </div>
      </template>
      
    </div>
  </template>

  <script>

      Polymer('th-lens-node', {
      // componentInput: [],
      componentOutput: [],
      type: 'transform',
      pathToComponents: '../',
      componentList: [
          {name:'th-data-table', friendly: 'Data table', type: 'input'},
          {name:'th-csv', friendly: 'CSV Loader', type: 'input'},
          {name: 'th-enigma', friendly: 'Enigma Data Loader', type: 'input'},
          
          {name:'th-array-function', friendly: 'Map/Reduce Function (JavaScript)', type: 'transform'},
          {name:'th-geocoder-firebase', friendly: 'Get Geocodes for Map', type: 'transform'},
          {name:'th-data-group-by', friendly: 'Group Data', type: 'transform'},
          {name:'th-data-split', friendly: 'Split Column', type: 'transform'},
          {name:'th-data-criterion', friendly: 'Filter Data', type: 'transform'},
          {name:'th-data-sort', friendly: 'Sort Data', type: 'transform'},
          {name:'th-data-join', friendly: 'Join Columns', type: 'transform'},

          {name:'th-google-map', friendly: 'Google Map', type: 'visualize'},
          {name:'th-google-bar-chart', friendly: 'Google Bar Chart', type: 'visualize'},
          {name:'th-mapbox', friendly: 'Mapbox Map', type: 'visualize'},
          {name:'th-google-line', friendly: 'Google Line Graph', type: 'visualize'},
          {name:'th-line-graph-touch', friendly: 'Single Line Graph', type: 'visualize'},
          {name:'th-google-scatter-bubble', friendly: 'Bubble Chart', type: 'visualize'},
          {name:'th-google-pie', friendly: 'Pie Chart', type: 'visualize'},
          {name:'th-n-bar-chart-horizontal', friendly: 'Horizontal Bar Chart', type: 'visualize'},
          {name:'th-n-bar-chart', friendly: 'Bar Chart', type: 'visualize'}
      ],
      domReady: function() {
        var self = this;
        this.component = this.$.component.getDistributedNodes()[1];
        
      },
      addElement: function(e, detail, selection){
        var self = this,
            name = selection.className,
            pathToEl = self.pathToComponents + name + "/" + name + ".html";

        Polymer.import([pathToEl], function(){ // TODO: this path is different in the lenscomposer app -- doesnt point to bower_components directory
          self.component = document.createElement(name);
          if (self.type =="visualize"){
            self.component.input = self.selectedComponentInput || self.componentInput;
          }

          console.log(self.component.input);
          self.appendChild(self.component);
          self.componentName = selection.label
          self.setObservers();      
        })
        
      },
      removeElement: function(e, detail, selection){
        var self = this;
        self.removeChild(self.component);
        self.component = null;
        
      },
      componentChanged: function(){
        var self = this;
          
        if (self.component){
         
          self.component.animateOnInit = true;
          self.component.style.width = "100%";
          self.getFieldsFromComponent();
          self.component.input = self.selectedComponentInput || self.componentInput;
          // if (self.$.outputTable){
          //   self.$.outputTable.input = self.component.output;
          // }
        } else {
          if (self.$.outputTable){ // for Transform nodes
            self.$.outputTable.input = self.componentInput;
          }
        }
      },
      componentInputChanged: function(){
        console.log("Component input changed")
          var self = this;
console.log("componentInputChanged");
          if (self.component && self.componentInput.length > 0){
            
            if(self.showDataSelector){
              console.log("filter input thru dataselector");
              self.$.dataselector.input = self.componentInput;
              self.component.input = self.selectedComponentInput;

              // self.component.input = self.componentInput.map(function(item){return item});
              // self.component.init();

            } else {
              self.component.input = self.componentInput;
            }
          }

          if(self.$.outputTable && !self.component){
            self.$.outputTable.input = self.componentInput
          }
      },
      setObservers: function(){
        var self = this;

        // // Observes changes in the output of the first table, which is the component input
        // var dataTableObserver = new PathObserver(self.$.inputTable, 'output').open(function(newValue, oldValue){
        //   console.log("input table observer change");
        //   if(!self.showDataSelector){
            
        //   self.component.input = newValue;
        //   }

        // });


        // var dataSelectorObserver = new PathObserver(self.$.dataselector, 'output').open(function(newValue, oldValue){
        //   console.log("selector observer change");
        //   self.component.input = newValue;
          

        // });


        // Observes changes in the output of the component and binds the new value to componentOutput
        var componentOutputObserver = new PathObserver(self.component, 'output').open(function(newValue, oldValue){
          console.log("component output observer change");
          self.componentOutput = self.component.output;    

        })
        
      },

      // When componentOutput changes, the output data table updates with the combined input/output; if there is no output table,
      // the output of the node is updated
      componentOutputChanged: function(){
        var self = this;
        if (self.$.outputTable){
          self.$.outputTable.input = self.componentOutput;
        } else if (self.type != "visualize") {
          self.output = self.componentOutput;
        }

      },
      filterByType: function(value){
        var self = this;
        var componentList = value.filter(function(component){ return component.type === self.type });
        return componentList;
      
        
      },
      getFieldsFromComponent: function(){
        var self = this;
        if (self.component && self.component.getMetaData){
          self.showDataSelector = true;
          var metadata = self.component.getMetaData();
          self.fields = metadata.fields || metadata.inputAttr.chartData.fields;
          // var dataSelectorObserver = new PathObserver(self.$.dataselector, 'output').open(function(newValue, oldValue){
            
          //   self.component.input = newValue;

          // })


          // var dataSelectorObserver = new PathObserver(self.$.dataselector, 'output').open(function(newValue, oldValue){
            
          //   self.component.input = newValue;

          // })
        } else {
          self.showDataSelector = false;
          // var inputTableObserver = new PathObserver(self.$.inputTable, 'output').open(function(newValue, oldValue){
            
          //   self.component.input = newValue;

          // })
        }
      },
      selectedComponentInputChanged: function(newValue, oldValue){
        var self = this;
        console.log("selectedComponentInputChanged");
        console.log(self.component);
        self.component.input = newValue;
      },
      toggle: function(e, detail, selection){
        var self = this;
        var target = selection.dataset.target;        
        e.stopPropagation();
        self.shadowRoot.querySelector('#'+target).toggle();
      }

      // NOTES:
      // inputtable output flows to:
      // - component in transform node
      // - component in visual node if there showDataselector is false
      // - dataSelector in visual node if showDataslector is true
      // - output in visual node (map it out)
      // data selector output flows to:
      // - component input in visual node
      // component output flows to:
      // - output in input node
      // - outputtable in transform node
      // - nowhere in visual node
      // outputtable output flows to:
      // - output in transform node
        
    });

  </script>
</polymer-element>
